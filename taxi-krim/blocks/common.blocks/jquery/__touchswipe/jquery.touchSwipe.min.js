/*!
 * @fileOverview TouchSwipe - jQuery Plugin
 * @version 1.6.18
 *
 * @author Matt Bryson http://www.github.com/mattbryson
 * @see https://github.com/mattbryson/TouchSwipe-Jquery-Plugin
 * @see http://labs.rampinteractive.co.uk/touchSwipe/
 * @see http://plugins.jquery.com/project/touchSwipe
 * @license
 * Copyright (c) 2010-2015 Matt Bryson
 * Dual licensed under the MIT or GPL Version 2 licenses.
 *
 */
!(function (factory) { typeof define === 'function' && define.amd && define.amd.jQuery ? define(['jquery'], factory) : factory(typeof module !== 'undefined' && module.exports ? require('jquery') : jQuery); }(($) => {
  function init(options) {
    return !options || void 0 !== options.allowPageScroll || void 0 === options.swipe && void 0 === options.swipeStatus || (options.allowPageScroll = NONE), void 0 !== options.click && void 0 === options.tap && (options.tap = options.click), options || (options = {}), options = $.extend({}, $.fn.swipe.defaults, options), this.each(function () {
      let $this = $(this),
        plugin = $this.data(PLUGIN_NS); plugin || (plugin = new TouchSwipe(this, options), $this.data(PLUGIN_NS, plugin));
    });
  } function TouchSwipe(element, options) {
    function touchStart(jqEvent) {
      if (!(getTouchInProgress() || $(jqEvent.target).closest(options.excludedElements, $element).length > 0)) {
        const event = jqEvent.originalEvent ? jqEvent.originalEvent : jqEvent; if (!event.pointerType || event.pointerType != 'mouse' || options.fallbackToMouseEvents != 0) {
          let ret,
            touches = event.touches,
            evt = touches ? touches[0] : event; return phase = PHASE_START, touches ? fingerCount = touches.length : options.preventDefaultEvents !== !1 && jqEvent.preventDefault(), distance = 0, direction = null, currentDirection = null, pinchDirection = null, duration = 0, startTouchesDistance = 0, endTouchesDistance = 0, pinchZoom = 1, pinchDistance = 0, maximumsMap = createMaximumsData(), cancelMultiFingerRelease(), createFingerData(0, evt), !touches || fingerCount === options.fingers || options.fingers === ALL_FINGERS || hasPinches() ? (startTime = getTimeStamp(), fingerCount == 2 && (createFingerData(1, touches[1]), startTouchesDistance = endTouchesDistance = calculateTouchesDistance(fingerData[0].start, fingerData[1].start)), (options.swipeStatus || options.pinchStatus) && (ret = triggerHandler(event, phase))) : ret = !1, ret === !1 ? (phase = PHASE_CANCEL, triggerHandler(event, phase), ret) : (options.hold && (holdTimeout = setTimeout($.proxy(() => { $element.trigger('hold', [event.target]), options.hold && (ret = options.hold.call($element, event, event.target)); }, this), options.longTapThreshold)), setTouchInProgress(!0), null);
        }
      }
    } function touchMove(jqEvent) {
      const event = jqEvent.originalEvent ? jqEvent.originalEvent : jqEvent; if (phase !== PHASE_END && phase !== PHASE_CANCEL && !inMultiFingerRelease()) {
        let ret,
          touches = event.touches,
          evt = touches ? touches[0] : event,
          currentFinger = updateFingerData(evt); if (endTime = getTimeStamp(), touches && (fingerCount = touches.length), options.hold && clearTimeout(holdTimeout), phase = PHASE_MOVE, fingerCount == 2 && (startTouchesDistance == 0 ? (createFingerData(1, touches[1]), startTouchesDistance = endTouchesDistance = calculateTouchesDistance(fingerData[0].start, fingerData[1].start)) : (updateFingerData(touches[1]), endTouchesDistance = calculateTouchesDistance(fingerData[0].end, fingerData[1].end), pinchDirection = calculatePinchDirection(fingerData[0].end, fingerData[1].end)), pinchZoom = calculatePinchZoom(startTouchesDistance, endTouchesDistance), pinchDistance = Math.abs(startTouchesDistance - endTouchesDistance)), fingerCount === options.fingers || options.fingers === ALL_FINGERS || !touches || hasPinches()) { if (direction = calculateDirection(currentFinger.start, currentFinger.end), currentDirection = calculateDirection(currentFinger.last, currentFinger.end), validateDefaultEvent(jqEvent, currentDirection), distance = calculateDistance(currentFinger.start, currentFinger.end), duration = calculateDuration(), setMaxDistance(direction, distance), ret = triggerHandler(event, phase), !options.triggerOnTouchEnd || options.triggerOnTouchLeave) { let inBounds = !0; if (options.triggerOnTouchLeave) { const bounds = getbounds(this); inBounds = isInBounds(currentFinger.end, bounds); }!options.triggerOnTouchEnd && inBounds ? phase = getNextPhase(PHASE_MOVE) : options.triggerOnTouchLeave && !inBounds && (phase = getNextPhase(PHASE_END)), phase != PHASE_CANCEL && phase != PHASE_END || triggerHandler(event, phase); } } else phase = PHASE_CANCEL, triggerHandler(event, phase); ret === !1 && (phase = PHASE_CANCEL, triggerHandler(event, phase));
      }
    } function touchEnd(jqEvent) {
      let event = jqEvent.originalEvent ? jqEvent.originalEvent : jqEvent,
        touches = event.touches; if (touches) { if (touches.length && !inMultiFingerRelease()) return startMultiFingerRelease(event), !0; if (touches.length && inMultiFingerRelease()) return !0; } return inMultiFingerRelease() && (fingerCount = fingerCountAtRelease), endTime = getTimeStamp(), duration = calculateDuration(), didSwipeBackToCancel() || !validateSwipeDistance() ? (phase = PHASE_CANCEL, triggerHandler(event, phase)) : options.triggerOnTouchEnd || options.triggerOnTouchEnd === !1 && phase === PHASE_MOVE ? (options.preventDefaultEvents !== !1 && jqEvent.cancelable !== !1 && jqEvent.preventDefault(), phase = PHASE_END, triggerHandler(event, phase)) : !options.triggerOnTouchEnd && hasTap() ? (phase = PHASE_END, triggerHandlerForGesture(event, phase, TAP)) : phase === PHASE_MOVE && (phase = PHASE_CANCEL, triggerHandler(event, phase)), setTouchInProgress(!1), null;
    } function touchCancel() { fingerCount = 0, endTime = 0, startTime = 0, startTouchesDistance = 0, endTouchesDistance = 0, pinchZoom = 1, cancelMultiFingerRelease(), setTouchInProgress(!1); } function touchLeave(jqEvent) { const event = jqEvent.originalEvent ? jqEvent.originalEvent : jqEvent; options.triggerOnTouchLeave && (phase = getNextPhase(PHASE_END), triggerHandler(event, phase)); } function removeListeners() { $element.unbind(START_EV, touchStart), $element.unbind(CANCEL_EV, touchCancel), $element.unbind(MOVE_EV, touchMove), $element.unbind(END_EV, touchEnd), LEAVE_EV && $element.unbind(LEAVE_EV, touchLeave), setTouchInProgress(!1); } function getNextPhase(currentPhase) {
      let nextPhase = currentPhase,
        validTime = validateSwipeTime(),
        validDistance = validateSwipeDistance(),
        didCancel = didSwipeBackToCancel(); return !validTime || didCancel ? nextPhase = PHASE_CANCEL : !validDistance || currentPhase != PHASE_MOVE || options.triggerOnTouchEnd && !options.triggerOnTouchLeave ? !validDistance && currentPhase == PHASE_END && options.triggerOnTouchLeave && (nextPhase = PHASE_CANCEL) : nextPhase = PHASE_END, nextPhase;
    } function triggerHandler(event, phase) {
      let ret,
        touches = event.touches; return (didSwipe() || hasSwipes()) && (ret = triggerHandlerForGesture(event, phase, SWIPE)), (didPinch() || hasPinches()) && ret !== !1 && (ret = triggerHandlerForGesture(event, phase, PINCH)), didDoubleTap() && ret !== !1 ? ret = triggerHandlerForGesture(event, phase, DOUBLE_TAP) : didLongTap() && ret !== !1 ? ret = triggerHandlerForGesture(event, phase, LONG_TAP) : didTap() && ret !== !1 && (ret = triggerHandlerForGesture(event, phase, TAP)), phase === PHASE_CANCEL && touchCancel(event), phase === PHASE_END && (touches ? touches.length || touchCancel(event) : touchCancel(event)), ret;
    } function triggerHandlerForGesture(event, phase, gesture) { let ret; if (gesture == SWIPE) { if ($element.trigger('swipeStatus', [phase, direction || null, distance || 0, duration || 0, fingerCount, fingerData, currentDirection]), options.swipeStatus && (ret = options.swipeStatus.call($element, event, phase, direction || null, distance || 0, duration || 0, fingerCount, fingerData, currentDirection), ret === !1)) return !1; if (phase == PHASE_END && validateSwipe()) { if (clearTimeout(singleTapTimeout), clearTimeout(holdTimeout), $element.trigger('swipe', [direction, distance, duration, fingerCount, fingerData, currentDirection]), options.swipe && (ret = options.swipe.call($element, event, direction, distance, duration, fingerCount, fingerData, currentDirection), ret === !1)) return !1; switch (direction) { case LEFT: $element.trigger('swipeLeft', [direction, distance, duration, fingerCount, fingerData, currentDirection]), options.swipeLeft && (ret = options.swipeLeft.call($element, event, direction, distance, duration, fingerCount, fingerData, currentDirection)); break; case RIGHT: $element.trigger('swipeRight', [direction, distance, duration, fingerCount, fingerData, currentDirection]), options.swipeRight && (ret = options.swipeRight.call($element, event, direction, distance, duration, fingerCount, fingerData, currentDirection)); break; case UP: $element.trigger('swipeUp', [direction, distance, duration, fingerCount, fingerData, currentDirection]), options.swipeUp && (ret = options.swipeUp.call($element, event, direction, distance, duration, fingerCount, fingerData, currentDirection)); break; case DOWN: $element.trigger('swipeDown', [direction, distance, duration, fingerCount, fingerData, currentDirection]), options.swipeDown && (ret = options.swipeDown.call($element, event, direction, distance, duration, fingerCount, fingerData, currentDirection)); } } } if (gesture == PINCH) { if ($element.trigger('pinchStatus', [phase, pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom, fingerData]), options.pinchStatus && (ret = options.pinchStatus.call($element, event, phase, pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom, fingerData), ret === !1)) return !1; if (phase == PHASE_END && validatePinch()) switch (pinchDirection) { case IN: $element.trigger('pinchIn', [pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom, fingerData]), options.pinchIn && (ret = options.pinchIn.call($element, event, pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom, fingerData)); break; case OUT: $element.trigger('pinchOut', [pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom, fingerData]), options.pinchOut && (ret = options.pinchOut.call($element, event, pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom, fingerData)); } } return gesture == TAP ? phase !== PHASE_CANCEL && phase !== PHASE_END || (clearTimeout(singleTapTimeout), clearTimeout(holdTimeout), hasDoubleTap() && !inDoubleTap() ? (doubleTapStartTime = getTimeStamp(), singleTapTimeout = setTimeout($.proxy(() => { doubleTapStartTime = null, $element.trigger('tap', [event.target]), options.tap && (ret = options.tap.call($element, event, event.target)); }, this), options.doubleTapThreshold)) : (doubleTapStartTime = null, $element.trigger('tap', [event.target]), options.tap && (ret = options.tap.call($element, event, event.target)))) : gesture == DOUBLE_TAP ? phase !== PHASE_CANCEL && phase !== PHASE_END || (clearTimeout(singleTapTimeout), clearTimeout(holdTimeout), doubleTapStartTime = null, $element.trigger('doubletap', [event.target]), options.doubleTap && (ret = options.doubleTap.call($element, event, event.target))) : gesture == LONG_TAP && (phase !== PHASE_CANCEL && phase !== PHASE_END || (clearTimeout(singleTapTimeout), doubleTapStartTime = null, $element.trigger('longtap', [event.target]), options.longTap && (ret = options.longTap.call($element, event, event.target)))), ret; } function validateSwipeDistance() { let valid = !0; return options.threshold !== null && (valid = distance >= options.threshold), valid; } function didSwipeBackToCancel() { let cancelled = !1; return options.cancelThreshold !== null && direction !== null && (cancelled = getMaxDistance(direction) - distance >= options.cancelThreshold), cancelled; } function validatePinchDistance() { return options.pinchThreshold === null || pinchDistance >= options.pinchThreshold; } function validateSwipeTime() { let result; return result = !options.maxTimeThreshold || !(duration >= options.maxTimeThreshold); } function validateDefaultEvent(jqEvent, direction) { if (options.preventDefaultEvents !== !1) if (options.allowPageScroll === NONE)jqEvent.preventDefault(); else { const auto = options.allowPageScroll === AUTO; switch (direction) { case LEFT: (options.swipeLeft && auto || !auto && options.allowPageScroll != HORIZONTAL) && jqEvent.preventDefault(); break; case RIGHT: (options.swipeRight && auto || !auto && options.allowPageScroll != HORIZONTAL) && jqEvent.preventDefault(); break; case UP: (options.swipeUp && auto || !auto && options.allowPageScroll != VERTICAL) && jqEvent.preventDefault(); break; case DOWN: (options.swipeDown && auto || !auto && options.allowPageScroll != VERTICAL) && jqEvent.preventDefault(); break; case NONE: } } } function validatePinch() {
      let hasCorrectFingerCount = validateFingers(),
        hasEndPoint = validateEndPoint(),
        hasCorrectDistance = validatePinchDistance(); return hasCorrectFingerCount && hasEndPoint && hasCorrectDistance;
    } function hasPinches() { return !!(options.pinchStatus || options.pinchIn || options.pinchOut); } function didPinch() { return !(!validatePinch() || !hasPinches()); } function validateSwipe() {
      let hasValidTime = validateSwipeTime(),
        hasValidDistance = validateSwipeDistance(),
        hasCorrectFingerCount = validateFingers(),
        hasEndPoint = validateEndPoint(),
        didCancel = didSwipeBackToCancel(),
        valid = !didCancel && hasEndPoint && hasCorrectFingerCount && hasValidDistance && hasValidTime; return valid;
    } function hasSwipes() { return !!(options.swipe || options.swipeStatus || options.swipeLeft || options.swipeRight || options.swipeUp || options.swipeDown); } function didSwipe() { return !(!validateSwipe() || !hasSwipes()); } function validateFingers() { return fingerCount === options.fingers || options.fingers === ALL_FINGERS || !SUPPORTS_TOUCH; } function validateEndPoint() { return fingerData[0].end.x !== 0; } function hasTap() { return !!options.tap; } function hasDoubleTap() { return !!options.doubleTap; } function hasLongTap() { return !!options.longTap; } function validateDoubleTap() { if (doubleTapStartTime == null) return !1; const now = getTimeStamp(); return hasDoubleTap() && now - doubleTapStartTime <= options.doubleTapThreshold; } function inDoubleTap() { return validateDoubleTap(); } function validateTap() { return (fingerCount === 1 || !SUPPORTS_TOUCH) && (isNaN(distance) || distance < options.threshold); } function validateLongTap() { return duration > options.longTapThreshold && distance < DOUBLE_TAP_THRESHOLD; } function didTap() { return !(!validateTap() || !hasTap()); } function didDoubleTap() { return !(!validateDoubleTap() || !hasDoubleTap()); } function didLongTap() { return !(!validateLongTap() || !hasLongTap()); } function startMultiFingerRelease(event) { previousTouchEndTime = getTimeStamp(), fingerCountAtRelease = event.touches.length + 1; } function cancelMultiFingerRelease() { previousTouchEndTime = 0, fingerCountAtRelease = 0; } function inMultiFingerRelease() { let withinThreshold = !1; if (previousTouchEndTime) { const diff = getTimeStamp() - previousTouchEndTime; diff <= options.fingerReleaseThreshold && (withinThreshold = !0); } return withinThreshold; } function getTouchInProgress() { return !($element.data(`${PLUGIN_NS}_intouch`) !== !0); } function setTouchInProgress(val) { $element && (val === !0 ? ($element.bind(MOVE_EV, touchMove), $element.bind(END_EV, touchEnd), LEAVE_EV && $element.bind(LEAVE_EV, touchLeave)) : ($element.unbind(MOVE_EV, touchMove, !1), $element.unbind(END_EV, touchEnd, !1), LEAVE_EV && $element.unbind(LEAVE_EV, touchLeave, !1)), $element.data(`${PLUGIN_NS}_intouch`, val === !0)); } function createFingerData(id, evt) { const f = { start: { x: 0, y: 0 }, last: { x: 0, y: 0 }, end: { x: 0, y: 0 } }; return f.start.x = f.last.x = f.end.x = evt.pageX || evt.clientX, f.start.y = f.last.y = f.end.y = evt.pageY || evt.clientY, fingerData[id] = f, f; } function updateFingerData(evt) {
      let id = void 0 !== evt.identifier ? evt.identifier : 0,
        f = getFingerData(id); return f === null && (f = createFingerData(id, evt)), f.last.x = f.end.x, f.last.y = f.end.y, f.end.x = evt.pageX || evt.clientX, f.end.y = evt.pageY || evt.clientY, f;
    } function getFingerData(id) { return fingerData[id] || null; } function setMaxDistance(direction, distance) { direction != NONE && (distance = Math.max(distance, getMaxDistance(direction)), maximumsMap[direction].distance = distance); } function getMaxDistance(direction) { if (maximumsMap[direction]) return maximumsMap[direction].distance; } function createMaximumsData() { const maxData = {}; return maxData[LEFT] = createMaximumVO(LEFT), maxData[RIGHT] = createMaximumVO(RIGHT), maxData[UP] = createMaximumVO(UP), maxData[DOWN] = createMaximumVO(DOWN), maxData; } function createMaximumVO(dir) { return { direction: dir, distance: 0 }; } function calculateDuration() { return endTime - startTime; } function calculateTouchesDistance(startPoint, endPoint) {
      let diffX = Math.abs(startPoint.x - endPoint.x),
        diffY = Math.abs(startPoint.y - endPoint.y); return Math.round(Math.sqrt(diffX * diffX + diffY * diffY));
    } function calculatePinchZoom(startDistance, endDistance) { const percent = endDistance / startDistance * 1; return percent.toFixed(2); } function calculatePinchDirection() { return pinchZoom < 1 ? OUT : IN; } function calculateDistance(startPoint, endPoint) { return Math.round(Math.sqrt(Math.pow(endPoint.x - startPoint.x, 2) + Math.pow(endPoint.y - startPoint.y, 2))); } function calculateAngle(startPoint, endPoint) {
      let x = startPoint.x - endPoint.x,
        y = endPoint.y - startPoint.y,
        r = Math.atan2(y, x),
        angle = Math.round(180 * r / Math.PI); return angle < 0 && (angle = 360 - Math.abs(angle)), angle;
    } function calculateDirection(startPoint, endPoint) { if (comparePoints(startPoint, endPoint)) return NONE; const angle = calculateAngle(startPoint, endPoint); return angle <= 45 && angle >= 0 ? LEFT : angle <= 360 && angle >= 315 ? LEFT : angle >= 135 && angle <= 225 ? RIGHT : angle > 45 && angle < 135 ? DOWN : UP; } function getTimeStamp() { const now = new Date(); return now.getTime(); } function getbounds(el) {
      el = $(el); let offset = el.offset(),
        bounds = {
          left: offset.left, right: offset.left + el.outerWidth(), top: offset.top, bottom: offset.top + el.outerHeight(),
        }; return bounds;
    } function isInBounds(point, bounds) { return point.x > bounds.left && point.x < bounds.right && point.y > bounds.top && point.y < bounds.bottom; } function comparePoints(pointA, pointB) { return pointA.x == pointB.x && pointA.y == pointB.y; } var options = $.extend({}, options),
      useTouchEvents = SUPPORTS_TOUCH || SUPPORTS_POINTER || !options.fallbackToMouseEvents,
      START_EV = useTouchEvents ? SUPPORTS_POINTER ? SUPPORTS_POINTER_IE10 ? 'MSPointerDown' : 'pointerdown' : 'touchstart' : 'mousedown',
      MOVE_EV = useTouchEvents ? SUPPORTS_POINTER ? SUPPORTS_POINTER_IE10 ? 'MSPointerMove' : 'pointermove' : 'touchmove' : 'mousemove',
      END_EV = useTouchEvents ? SUPPORTS_POINTER ? SUPPORTS_POINTER_IE10 ? 'MSPointerUp' : 'pointerup' : 'touchend' : 'mouseup',
      LEAVE_EV = useTouchEvents ? SUPPORTS_POINTER ? 'mouseleave' : null : 'mouseleave',
      CANCEL_EV = SUPPORTS_POINTER ? SUPPORTS_POINTER_IE10 ? 'MSPointerCancel' : 'pointercancel' : 'touchcancel',
      distance = 0,
      direction = null,
      currentDirection = null,
      duration = 0,
      startTouchesDistance = 0,
      endTouchesDistance = 0,
      pinchZoom = 1,
      pinchDistance = 0,
      pinchDirection = 0,
      maximumsMap = null,
      $element = $(element),
      phase = 'start',
      fingerCount = 0,
      fingerData = {},
      startTime = 0,
      endTime = 0,
      previousTouchEndTime = 0,
      fingerCountAtRelease = 0,
      doubleTapStartTime = 0,
      singleTapTimeout = null,
      holdTimeout = null; try { $element.bind(START_EV, touchStart), $element.bind(CANCEL_EV, touchCancel); } catch (e) { $.error(`events not supported ${START_EV},${CANCEL_EV} on jQuery.swipe`); } this.enable = function () { return this.disable(), $element.bind(START_EV, touchStart), $element.bind(CANCEL_EV, touchCancel), $element; }, this.disable = function () { return removeListeners(), $element; }, this.destroy = function () { removeListeners(), $element.data(PLUGIN_NS, null), $element = null; }, this.option = function (property, value) { if (typeof property === 'object')options = $.extend(options, property); else if (void 0 !== options[property]) { if (void 0 === value) return options[property]; options[property] = value; } else { if (!property) return options; $.error(`Option ${property} does not exist on jQuery.swipe.options`); } return null; };
  } var VERSION = '1.6.18',
    LEFT = 'left',
    RIGHT = 'right',
    UP = 'up',
    DOWN = 'down',
    IN = 'in',
    OUT = 'out',
    NONE = 'none',
    AUTO = 'auto',
    SWIPE = 'swipe',
    PINCH = 'pinch',
    TAP = 'tap',
    DOUBLE_TAP = 'doubletap',
    LONG_TAP = 'longtap',
    HORIZONTAL = 'horizontal',
    VERTICAL = 'vertical',
    ALL_FINGERS = 'all',
    DOUBLE_TAP_THRESHOLD = 10,
    PHASE_START = 'start',
    PHASE_MOVE = 'move',
    PHASE_END = 'end',
    PHASE_CANCEL = 'cancel',
    SUPPORTS_TOUCH = 'ontouchstart' in window,
    SUPPORTS_POINTER_IE10 = window.navigator.msPointerEnabled && !window.navigator.pointerEnabled && !SUPPORTS_TOUCH,
    SUPPORTS_POINTER = (window.navigator.pointerEnabled || window.navigator.msPointerEnabled) && !SUPPORTS_TOUCH,
    PLUGIN_NS = 'TouchSwipe',
    defaults = {
      fingers: 1, threshold: 75, cancelThreshold: null, pinchThreshold: 20, maxTimeThreshold: null, fingerReleaseThreshold: 250, longTapThreshold: 500, doubleTapThreshold: 200, swipe: null, swipeLeft: null, swipeRight: null, swipeUp: null, swipeDown: null, swipeStatus: null, pinchIn: null, pinchOut: null, pinchStatus: null, click: null, tap: null, doubleTap: null, longTap: null, hold: null, triggerOnTouchEnd: !0, triggerOnTouchLeave: !1, allowPageScroll: 'auto', fallbackToMouseEvents: !0, excludedElements: '.noSwipe', preventDefaultEvents: !0,
    }; $.fn.swipe = function (method) {
    let $this = $(this),
      plugin = $this.data(PLUGIN_NS); if (plugin && typeof method === 'string') { if (plugin[method]) return plugin[method](...Array.prototype.slice.call(arguments, 1)); $.error(`Method ${method} does not exist on jQuery.swipe`); } else if (plugin && typeof method === 'object')plugin.option(...arguments); else if (!(plugin || typeof method !== 'object' && method)) return init.apply(this, arguments); return $this;
  }, $.fn.swipe.version = VERSION, $.fn.swipe.defaults = defaults, $.fn.swipe.phases = {
    PHASE_START, PHASE_MOVE, PHASE_END, PHASE_CANCEL,
  }, $.fn.swipe.directions = {
    LEFT, RIGHT, UP, DOWN, IN, OUT,
  }, $.fn.swipe.pageScroll = {
    NONE, HORIZONTAL, VERTICAL, AUTO,
  }, $.fn.swipe.fingers = {
    ONE: 1, TWO: 2, THREE: 3, FOUR: 4, FIVE: 5, ALL: ALL_FINGERS,
  };
}));
